\section{BACKEND + DATENBANK}\label{ch:backend}

Das Backend wurde mit dem Framework \textbf{FastAPI} in Python umgesetzt und ist die einzige Schnittstelle zur Datenbank \textbf{MongoDB}.

\subsection{Datenbank}
Um eine MongoDB lokal (für die Entwicklung) zu starten, gibt es mehrere Möglichkeiten:
\begin{itemize}
\item Herunterladen von MongoDB über die offizielle Website oder einen Package Manager (z.B. ABT)
\item Starten eines einzelnen Docker Containers mittels  \textbf{docker run --name mongodb -d -p 27017:27017 mongo:4.4}
\item Starten mittels des existierenden Docker Compose Files \textbf{docker-compose up -d mongodb}
\end{itemize}
Die Datenbank wird dabei in der Standardkonfiguration genutzt, somit ist es nicht erforderlich Nutzer oder anderes anzulegen.
Lediglich sollte die Datenbank über den Standardport 27017 erreichbar sein. \\

MongoDB enthält zu Beginn einige Tabellen die zur Konfiguration und zur internen Konsistenz genutzt werden.
Die eigentlichen Daten werden dabei in einer neuen Datenbank (der Name dieser kann konfiguriert werden) gespeichert.
Eine solche Datenbank kann mehrere Collectionen beinhalten, das Äquivalent zu Tabellen in einer SQL Datenbank.
Diese Collectionen beinhalten i.d.R ähnliche Documente im Format BSON (Binary JSON). 

\subsection{Datenformat}
Es werden zwei Datenformate genutzt, die jeweils in einer eigenen Collection gespeichert werden : \textbf{Kategorien} und \textbf{Artikel}.

Listing \ref{lst:category_dtype} zeigt ein Kategorie Objekt, wie es in der Datenbank gespeichert sein könnte.
\begin{lstlisting}[caption={Kategorie Objekt},captionpos=b,showstringspaces=false, basicstyle=\small,label={lst:category_dtype}]
{
    "_id": ObjectID(abc123def456),
    "kategorie": "Beispielkategorie",
    "parent_kategorie" : null,
    "subkategorien"    : ["ghi789jkl101"],
    "artikel" : [
        {
        "name":"Beispielartikel",
        "id"  :"lmnopqrs333"
        }]
}
\end{lstlisting}

Das Feld \textbf{'\_id'} ist ein Primärschlüssel, welcher einzigartig ist und automatisch von MongoDB vergeben wird. 
Mit diesem können Objekte eindeutig referenziert werden.
Über \textbf{'kategorie'} wird der Name einer Kategorie als String gespeichert.
\textbf{'parent\_kategorie'} und \textbf{'subkategorien'} dienen dazu, eine Hierarchie zwischen den Kategorien zu etablieren. Dabei handelt es sich um eine Doppelreferenz, ähnlich einer \textit{Doppelt verketteten Liste}.
Dabei kann eine Kategorie jedoch mehrere Subkategorien enthalten, wohingegen maximal eine Parent-Kategorie definiert werden kann.
Ist der Parent jedoch None bzw. null, ist die Kategorie in der Hierarchie ganz oben.
Das Feld \textbf{'artikel'} enthält eine Liste von Artikelname sowie dessen ID. 
Dadruch können die Artikel zugeordnet werden, sowie im Frontend passend der Name unter entsprechender Kategorie angezeigt werden.
Das Beispiel zeigt bereits, dass eine Kategorie sowohl Subkategorien, als auch Artikel enthalten kann. \\

\begin{lstlisting}[caption={Artikel Objekt},captionpos=b,showstringspaces=false, basicstyle=\small,label={lst:article_dtype}]
{
    "_id": ObjectID(lmnopqrs333),
    "artikel_name": "Beispielartikel",
    "artikel_text": "Artikel ueber ...",
    "kategorie" : "abc123def456",
    "current_version": 2,
    "tags":["beispiel","tags"],
    "created": 01-01-2020,
    "old_versions" : [
        {
        "name":"Beispielartikel_alt",
        "text"  :"Hier war ..."
        "version": 1
        }]
}
\end{lstlisting}

Ein Artikel Objekt aus der Datenbank wird in Listing \ref{lst:article_dtype} dargestellt.
Die meisten Felder dienen den Informationen des Artikels, wie etwa \textbf{artikel\_name} (Überschrift) und \textbf{artikel\_text}.
Das \textbf{kategorie} Feld dient zur Verbindung mit entsprechender Kategorie.
Sollte ein Artikel geupdated werden, wird die alte Version in dem Feld \textbf{old\_versions} hinterlegt, und die Inhalte der anderen Felder geupdated.\\

Die Datenbankobjekte werden im Code als Pydantic Dataclasses hinterlegt, was das Parsen dieser Objekte (z.B. als JSON Payload) erleichtert. 
Dabei werden die Klassen mit dem Decorator \textbf{@dataclass} verziert und erhalten \textbf{TypeHints} mit entsprechden Datentypen

\begin{lstlisting}[language=python,caption={Kategorie Dataclass},captionpos=b,showstringspaces=false, basicstyle=\small,label={lst:dataclass}]
@dataclass
class Category():
    kategorie: str
    parent_kategorie: Optional[str] = None
    subkategorien: Optional[List[str]] =
        Field(default_factory=list)
    artikel: Optional[List[str]] =
        Field(default_factory=list)
\end{lstlisting}

\subsection{Backend}
Mittels dem Python Framework \textbf{FastAPI} werden diverse Endpoints bereitgestellt, die das Erstellen und Ausgeben der Datenobjekte ermöglicht.
Für Kategorien gibt es dabei folgende Datenpunkte:
\begin{itemize}
\item \textbf{GET /categories}: Alle Kategorien werden hierarchisch sortiert und ausgegeben.
\item \textbf{GET /categories/\{id oder name\}}: Eine bestimmte Kategorie wird ausgegeben. Kann auch genutzt werden, um zu prüfen, ob eine Kategorie existiert 
\item \textbf{POST /categories}: Anlegen einer neuen Kategorie
\item \textbf{DELETE /categories/\{id\}}: Löschen einer Kategorie mittels der ID
\end{itemize}


Die Artikel können über folgende Routen gemanaged werden:
\begin{itemize}
\item \textbf{GET /article/\{id\}}: Gebe einen Artikel mit allen Infos (z.B. Artikeltext) aus.
\item \textbf{POST /articles}: Erstelle einen neuen Artikel.
\item \textbf{POST /articles/update}: Ermöglicht das Update eines Artikels, benötigt jedoch die ID des ursprünglichen Objekts.
\item \textbf{DELETE /articles/\{id\}}:Löschen eines Artikels mittels der ID
\end{itemize}

Die Endpunkte (besonders die POST Routen) nutzen dabei ein automatisiertes Umwandeln zu entsprechenden Dataclasses.
Dies sorgt dafür, dass Pflichtfelder übergeben werden und nicht benötigte Elemente verworfen werden.\\
Über einen PyMongo Client werden diese Dataclasses also entweder von Route zur Datenbank weitergeleitet, oder aus der Datenbank zur Route.
Die Verbindung erfolgt dabei über eine \textbf{MONGO\_URI}, welche Hostnamen und Port beinhaltet. Dieser String sieht wie folgt aus: \textit{mongodb://localhost:27017/}. \\
Als tatsächlicher Webserver wird \textbf{uvicorn} genutzt, welcher im \textbf{\_\_main\_\_.py} gestartet wird. Dies ermöglicht es, das Backend mittels des Befehlt \textit{python -m backend} zu starten.

\subsection{Tests}
In einem separaten Testscript \textbf{test\_backend.py} werden die Routen getestet. 
Hierbei wird jedoch eine Testtabelle in der Datenbank genutzt, um nicht mit anderen Daten zu interferieren. 
In einer Setup-Methode werden dabei die Referenzen auf die Tabelle ausgetauscht. 
Der Server wird ebenfalls durch einen \textbf{TestClient} ersetzt, welcher in dem FastAPI Framework integriert ist.\\
Um die Endpoints für die Kategorien zu testen, werden mehrere Kategorien angelegt.
Dabei sind diese teilweise hierarchisch auf der gleichen Ebene, jedoch auch teilweise untergliedert. 
Nach den Inserts wird überprüft, ob gewünschte Hierarchie mit der echten Hierarchie übereinstimmt.
Nach Löschen der Kategorien wird getestet, dass keine Kategorie mehr in der Datenbank angelegt ist. \\
Das Testen der Artikel simuliert einen ähnlichen Objektzyklus, jedoch wird immer auch auf die passende Verbindung zur Kategorie geachtet.
So soll beispielsweise nach dem Updaten eines Artikels, ebenfalls der Artikelname in der Verknüpfung angepasst werden.\\
Die Tests können mittels des Befehls \textit{python -m pytest -s} gestartet werden.
